package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"regexp"
	"strings"

	"github.com/dlclark/regexp2"
)

func main() {
	flag.Parse()

	if err := run(); err != nil {
		log.Println(err)
	}
}

func run() error {
	if err := downloadPb3(); err != nil {
		return err
	}
	if err := handleEncode(); err != nil {
		return err
	}
	if err := handleDecode(); err != nil {
		return err
	}
	return nil
}

func downloadPb3() error {
	f, err := fetchGithubFile("protocolbuffers/protobuf-go", "internal/testprotos/textpb3/test.pb.go")
	if err != nil {
		return err
	}
	return ioutil.WriteFile("./textpb3/test.pb.go", []byte(f.Body), 0644)
}

func handleEncode() error {
	f, err := fetchGithubFile("protocolbuffers/protobuf-go", "encoding/protojson/encode_test.go")
	if err != nil {
		return err
	}

	// \{\s*desc:[\s\S]+?input:[\s\S]+?,\s*(want:\s*`[^`]+`|wantErr:\s*(true|false)),\s*\}(,|})
	r := regexp.MustCompile(`\{\s*desc:[\s\S]+?input:[\s\S]+?,\s*(want:\s*` + "`[^`]+`" + `|wantErr:\s*(true|false)),\s*\}(,|})`)
	f.Body = r.ReplaceAllStringFunc(f.Body, func(src string) string {
		if strings.Contains(src, "pb2.") {
			if strings.HasSuffix(src, "}") {
				return "}"
			}
			return ""
		}
		return src
	})
	f.Body = regexp.MustCompile(`import\s*\([^\)]+\)[\s\S]+detrand\.Disable\(\)\s*}`).ReplaceAllString(f.Body,
		`
import (
	"bytes"
	"encoding/json"
	"math"
	"testing"

	"github.com/google/go-cmp/cmp"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"

	jsoniter "github.com/json-iterator/go"
	"github.com/molon/jsoniterpb"
	pb3 "github.com/molon/jsoniterpb/internal/protojson/textpb3"
	"google.golang.org/protobuf/types/known/anypb"
	"google.golang.org/protobuf/types/known/durationpb"
	"google.golang.org/protobuf/types/known/emptypb"
	"google.golang.org/protobuf/types/known/fieldmaskpb"
	"google.golang.org/protobuf/types/known/structpb"
	"google.golang.org/protobuf/types/known/timestamppb"
	"google.golang.org/protobuf/types/known/wrapperspb"
)`)
	f.Body = regexp.MustCompile(`for _, tt := range tests \{[\s\S]+$`).ReplaceAllString(f.Body,
		`
	for _, tt := range tests {
		tt := tt
		if tt.skip {
			continue
		}
		t.Run(tt.desc, func(t *testing.T) {
			cfg := jsoniter.Config{SortMapKeys: true}.Froze()
			cfg.RegisterExtension(&jsoniterpb.ProtoExtension{
				UseEnumNumbers:  tt.mo.UseEnumNumbers,
				UseProtoNames:   tt.mo.UseProtoNames,
				EmitUnpopulated: tt.mo.EmitUnpopulated,
				Resolver:        tt.mo.Resolver,
			})
			b, err := cfg.MarshalIndent(tt.input, "", "  ")
			if err != nil && !tt.wantErr {
				t.Errorf("MarshalIndent() returned error: %v\n", err)
			}
			if err == nil && tt.wantErr {
				t.Errorf("MarshalIndent() got nil error, want error\n")
			}
			got := string(b)
			if compact(t, got) != compact(t, tt.want) {
				t.Errorf("MarshalIndent()\n<want>\n%v\n<got>\n%v\n", tt.want, got)
				if diff := cmp.Diff(tt.want, got); diff != "" {
					t.Errorf("MarshalIndent() diff -want +got\n%v\n", diff)
				}
			}
		})
	}
}

func compact(t *testing.T, want string) string {
	if want == "" {
		return want
	}
	var out bytes.Buffer
	err := json.Compact(&out, []byte(want))
	if err != nil {
		t.Errorf("Compact returned error: %v\n", err)
		return want
	}
	return out.String()
}
`)
	f.Body = fmt.Sprintf(`
// generated by go run gen.go; DO NOT EDIT
// github.com/protocolbuffers/protobuf-go
// commit: %s
// date: %s

`, f.Sha, f.Date,
	) + f.Body
	return ioutil.WriteFile("./tests/jsoniterpb_encode_test.go", []byte(f.Body), 0644)
}

func handleDecode() error {
	f, err := fetchGithubFile("protocolbuffers/protobuf-go", "encoding/protojson/decode_test.go")
	if err != nil {
		return err
	}
	// b, err := ioutil.ReadFile("./decode_test_upstream._go")
	// if err != nil {
	// 	return err
	// }
	// f := &GithubFile{
	// 	Body: string(b),
	// }

	// \{\s*desc:[\s\S]+?(?=(\{\s*desc:|\}\s*for))
	r := regexp2.MustCompile(`\{\s*desc:[\s\S]+?(?=(\{\s*desc:|\}\s*for))`, 0)
	f.Body, err = r.ReplaceFunc(f.Body, func(m regexp2.Match) string {
		src := m.GroupByNumber(0).String()
		if strings.Contains(src, "pb2.") ||
			strings.Contains(src, "testpb.") ||
			strings.Contains(src, "weakpb.") {
			return ""
		}
		return src
	}, -1, -1)
	f.Body = regexp.MustCompile(`import\s*\([^\)]+\)`).ReplaceAllString(f.Body,
		`import (
	"math"
	"strings"
	"testing"
	"regexp"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"

	pb3 "github.com/molon/jsoniterpb/internal/protojson/textpb3"
	"google.golang.org/protobuf/types/known/anypb"
	"google.golang.org/protobuf/types/known/durationpb"
	"google.golang.org/protobuf/types/known/emptypb"
	"google.golang.org/protobuf/types/known/fieldmaskpb"
	"google.golang.org/protobuf/types/known/structpb"
	"google.golang.org/protobuf/types/known/timestamppb"
	"google.golang.org/protobuf/types/known/wrapperspb"

	jsoniter "github.com/json-iterator/go"
	"github.com/molon/jsoniterpb"
)`)
	f.Body = regexp.MustCompile(`for _, tt := range tests \{[\s\S]+$`).ReplaceAllString(f.Body,
		strings.ReplaceAll(`
	const ignores = PLACEHOLDER
	[FuzzyDecode] not float
	[FuzzyDecode] not boolean
	[FuzzyDecode] integer string with trailing space
	[FuzzyDecode] integer string with leading space
	[FuzzyDecode] float string with leading space
	[FuzzyDecode] double string with trailing space
	[FuzzyDecode] enum set to number string
	[FuzzyDecode] map contains null for message value
	[ErrMsgNotSame] string with invalid UTF-8
	[ErrMsgNotSame] camelCase name
	[ErrMsgNotSame] message set to non-message
	[ErrMsgNotSame] nested message set to non-message
	[ErrMsgNotSame] map contains contains message value with invalid UTF8
	[ErrMsgNotSame] map key contains invalid UTF8
	[ErrMsgNotSame] Empty contains unknown
	[ErrMsgNotSame] StringValue_with_invalid_UTF8_error
	[ErrMsgNotSame] Value_string_with_invalid_UTF8
	[ErrMsgNotSame] Value_struct_with_invalid_UTF8_string
	[ErrMsgNotSame] Value_list_with_invalid_UTF8_string
	[ErrMsgNotSame] Any with missing Empty
	[ErrMsgNotSame] Any with StringValue containing invalid UTF8
	[ErrMsgNotSame] Any with Value of StringValue
	[ErrMsgNotSame] Any with missing @type
	[ErrMsgNotSame] Any with empty @type
	[ErrMsgNotSame] Any with duplicate value
	[NotSupport] proto name and json_name
	[NotSupport] duplicate field names
	[NotSupport] oneof set to more than one field
	[NotSupport] oneof set to null and value
	[NotSupport] map contains duplicate keys
	[NotSupport] DiscardUnknown: Any without type
	PLACEHOLDER
	
	ignoreDescs := map[string]string{}
	r := regexp.MustCompile("\\[([^\\]]+)\\]\\s*(.+)")
	for _, v := range strings.Split(ignores, "\n") {
		v = strings.TrimSpace(v)
		if v=="" {
			continue
		}
		es := r.FindAllStringSubmatch(v, -1)
		ignoreDescs[strings.TrimSpace(es[0][2])] = strings.TrimSpace(es[0][1])
	}

	for _, tt := range tests {
		tt := tt
		if tt.skip {
			continue
		}

		if sign,ok := ignoreDescs[tt.desc];ok {
			switch sign {
			case "FuzzyDecode","NotSupport","ErrMsgNotSame":
				continue
			}
		}

		t.Run(tt.desc, func(t *testing.T) {
			cfg := jsoniter.Config{SortMapKeys: true,DisallowUnknownFields: !tt.umo.DiscardUnknown}.Froze()
			cfg.RegisterExtension(&jsoniterpb.ProtoExtension{Resolver: tt.umo.Resolver})
			err := cfg.Unmarshal([]byte(tt.inputText), tt.inputMessage)
			if err != nil {
				if tt.wantErr == "" {
					t.Errorf("Unmarshal() got unexpected error: %v", err)
				} else {
					if strings.Contains(tt.wantErr, "invalid value for") {
						return
					}
					if !strings.Contains(err.Error(), tt.wantErr) {
						t.Errorf("Unmarshal() error got %q, want %q", err, tt.wantErr)
					}
				} 
				return
			}
			if tt.wantErr != "" {
				t.Errorf("Unmarshal() got nil error, want error %q", tt.wantErr)
			}
			if tt.wantMessage != nil && !proto.Equal(tt.inputMessage, tt.wantMessage) {
				t.Errorf("Unmarshal()\n<got>\n%v\n<want>\n%v\n", tt.inputMessage, tt.wantMessage)
			}
		})
	}
}	

`, "PLACEHOLDER", "`"))
	f.Body = fmt.Sprintf(`
// generated by go run gen.go; DO NOT EDIT
// github.com/protocolbuffers/protobuf-go
// commit: %s
// date: %s

`, f.Sha, f.Date,
	) + f.Body
	return ioutil.WriteFile("./tests/jsoniterpb_decode_test.go", []byte(f.Body), 0644)
}

var (
	shaRE  = regexp.MustCompile(`"sha":"([^"]+)"`)
	dateRE = regexp.MustCompile(`"committer":{[^{]+"date":"([^"]+)"`)
)

func gitCommit(gitCommitURL string) (sha, date string, retErr error) {
	res, err := http.Get(gitCommitURL)
	if err != nil {
		return "", "", err
	}
	if res.StatusCode != http.StatusOK {
		return "", "", fmt.Errorf("bad GET status for %s: %s", gitCommitURL, res.Status)
	}
	defer res.Body.Close()
	b, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return "", "", err
	}
	if m := shaRE.FindSubmatch(b); m != nil {
		sha = string(m[1])
	}
	if m := dateRE.FindSubmatch(b); m != nil {
		date = string(m[1])
	}
	if sha == "" || date == "" {
		retErr = fmt.Errorf("could not find commit SHA and date in %s", gitCommitURL)
	}
	return sha, date, retErr
}

type GithubFile struct {
	Body string
	Sha  string
	Date string
}

func fetchGithubFile(repo, path string) (*GithubFile, error) {
	// "https://api.github.com/repos/protocolbuffers/protobuf-go/commits?path=encoding/protojson/encode_test.go"
	commitURL := fmt.Sprintf("https://api.github.com/repos/%s/commits?path=%s", repo, path)
	sha, date, err := gitCommit(commitURL)
	if err != nil {
		return nil, err
	}

	rawURL := fmt.Sprintf("https://raw.githubusercontent.com/%s/%s/%s", repo, sha, path)
	res, err := http.Get(rawURL)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("bad GET status for %s: %s", rawURL, res.Status)
	}
	defer res.Body.Close()
	b, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}
	return &GithubFile{
		Body: string(b),
		Sha:  sha,
		Date: date,
	}, nil
}
